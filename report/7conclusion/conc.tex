\chapter{Conclusion}
Throughout this thesis I have documented the theory and implementation of a deep G-buffer and its use for two different kinds of global illumination techniques. Additionally, I have documented and implemented an omni-directional shadow map for use with a point light as well as reconstruction of view-space and world-space positions from a single G-buffer. I started by describing the basic idea of deferred rendering before moving on to the deep G-buffer and how to reconstruct positions from a depth buffer with the use of inverse matrices. Then I described the generation and use of an omni-directional shadow map based on a cubemap, after which I described radiosity, taking a point of departure in the rendering equation and using the patch method as a point of reference. I explained the screen-space method and the Quasi-Monte Carlo method used to approximate the radiosity equation. Finally I described the Alchemy AO equation and the Gaussian filter used to even out the noisy results of radiosity and SSAO. I used the concepts described in the theory chapter to implement a rendering pipeline, and documented the code in the implementation chapter. Finally, I posted screen shots and frame times of my results and drew my conclusions. Firstly, I conclude that generating the G-buffer in a single pass was the superior approach compared to multiple passes, both in terms of efficiency and code readability. I concluded that the scene reconstruction provided a reasonable time for a lambertian shader for the memory it saves, but the shadow map generation was too inefficient to be practical, despite producing nice results. I moved on to the radiosity and SSAO results and concluded that while radiosity was too expensive in running time per bounce, the SSAO algorithm ran within an acceptable time frame. For the Gaussian filter I concluded that, while it needs some more refined edge detection, it smooths the results out appropriately. Ultimately I concluded that I have not demonstrated the advantages of a G-buffer to a satisfactory degree, and would not consider it worth the extra running time on my system. I note, however, that the combined running times are very close to 20FPS, which is a fair goal for an interactive application. However, I successfully explained, implemented and demonstrated screen-space radiosity, SSAO, a gaussian filter and omni-directional shadow mapping, and conclude that with some optimisations the final running times could be brought down to acceptable levels.